\documentclass[12pt,letterpaper]{article}
\usepackage[margin=.65in]{geometry}
\usepackage{graphicx}
\usepackage{amsfonts}
\usepackage{enumerate}
\usepackage{setspace}
\usepackage{mathtools}
\usepackage{siunitx}
\usepackage{multicol}
\usepackage{grffile}
\usepackage{hyperref}
\usepackage{pbox}
\usepackage{qtree}
\usepackage{tikz}
\usepackage{tkz-graph}
\usepackage{listings}
%\usepackage{slashbox}
\usepackage{array}
%\usepackage{logicsym}
\usepackage{amssymb}
\usepackage{etoolbox}
\usepackage{pdfpages}
\usepackage{longtable}

\lstset{basicstyle=\ttfamily,
escapeinside={||},
mathescape=true}

\sisetup{per-mode=symbol, group-digits=false, separate-uncertainty=true}

\renewcommand{\tt}[1]{\texttt{#1}}

%Centered multi-row box
\newcommand{\cmrb}[3][0.8in]{\parbox{#1}{\centering #2 \\ #3 } }

%Circled character
\newcommand*\circled[1]{\tikz[baseline=(char.base)]{
            \node[shape=circle,draw,inner sep=2pt] (char) {#1};}}

\makeatletter
\newcommand{\vast}{\bBigg@{4}}
\newcommand{\Vast}{\bBigg@{5}}
\makeatother

\everymath{\displaystyle}

\newcolumntype{T}{p{2in}<{\ttfamily}}

\newcommand{\sh}{\tt{store\_handler}}
\renewcommand{\sp}{\tt{storage\_process}}
\newcommand{\gs}{\tt{gen\_server}}

\author{Alejandro Frias \and Ravi Kumar \and David Scott}
\date{\today}
\title{Distributed Key-Value Storage Algorithm\\CS181E --- Distributed Systems\\Assignment 5}
\begin{document}
\maketitle


\onehalfspacing
\section*{Algorithm Description}


\setlength{\extrarowheight}{5pt}
\setlength{\LTcapwidth}{\textwidth}

\begin{longtable}{p{4.5in}T}
\caption{Caption}
\label{msgTable}\\
\textbf{Message Description} & \textbf{Erlang Pattern} \\
\hline
\endhead
\hline \multicolumn{2}{|r|}{{This table continues on the next page...}} \\ \hline
\endfoot
\endlastfoot

Store Request. Sent by either OW or a \sp to a \sp to store \tt{value} for \tt{key}. These are only ever received by storage processes in the network. When an \sp receives such a message, it first checks if the hashed key is equal to its own ID. If it is, then it stores the value for the specified key, and sends a \tt{backup\_store} message to its \sh. If not, it forwards it to the closest storage process to the destination (closest here meaning nearest process \textit{before} the destination, since processes can only send messages forward in the ring). &
\{Pid, Ref, store, Key, Value\} \\

Stored Confirmation. Sent by an \sh to OW after the corresponding request has been stored in the proper storage process and the data has been backed up in the \sh sending the message. &
\{Ref, stored, Old\_Value\} \\

Retrieve Request. Sent by OW and storage processes; received by storage processes. When a storage processes receives such a message, it checks if the hash of the key is equal to its own process ID. If it is, the storage process has the value for that key, and replies with a retrieve response. If not, it forwards it to the closest storage process to the destination (closest as defined above). &
\{Pid, Ref, retrieve, Key\} \\

Retrieve Response. Sent by storage processes to the OW. After a storage process receives a retrieve request meant for it, it looks up the relevant value and reports it to the requesting process in the OW. &
\{Ref, retrieved, Value\} \\

First Key Request. Sent by the OW to storage processes, and by storage processes to storage handlers. When a storage process receieves this, it will forward the message up to its storage handler. When such a message is received by a storage handler, it will start a first key computation by adding the ref to its list of ongoing computations and sending a First Key Computation message to the next node in the ring. &
\{Pid, Ref, first\_key\} \\

Last Key Request. Sent by the OW to storage processes, and by storage processes to storage handlers. When a storage process receieves this, it will forward the message up to its storage handler. When such a message is received by a storage handler, it will start a last key computation by adding the ref to its list of ongoing computations and sending a Last Key Computation message to the next node in the ring. &
\{Pid, Ref, last\_key\} \\

Num Keys Request. Sent by the OW to storage processes, and by storage processes to storage handlers. When a storage process receieves this, it will forward the message up to its storage handler. When such a message is received by a storage handler, it will start a num keys computation by adding the ref to its list of ongoing computations and sending a Num Keys Computation message to the next node in the ring. &
\{Pid, Ref, num\_keys\} \\

Node List Request. Sent by the OW to storage processes, and by storage processes to storage handlers. When a \sp receieves this, it will forward the message up to its \sh When such a message is received by a \sh, it will query the global registry for the list of nodes and report that data to the requester. &
\{Pid, Ref, node\_list\} \\

Request Result. Sent to the OW by a storage handler. This reports the result of a First Key, Last Key, Num Keys, or Node List Request to the original requester after the storage handlers have finished computing the result. &
\{Ref, result, Result\} \\

Failure Notification. Sent to the OW by storage handlers or storage processes to notify the OW that a particular computation has failed. &
\{Ref, failure\} \\

Leave Request. Sent by the OW to storage processes and by storage processes to storage handlers. When received by a \sp, it forwards the message to its \sh. When received by an \sh, it immediately kills all storage processes on the node it is running on, and kills itself. &
\{Pid, Ref, leave\} \\

Backup Store Request. Sent by \sh and \sp, and received by \sh. If a \sh receives this message from a \sp, it forwards the message to the next \sh. If an \sh receives this message from another \sh, it will back up the data in the message, then notify the OW of the store's success and the old value. & 
\{Pid, Ref, backup\_store, Key, Value, ProcessID\} \\

Messages About Keys.  Sent and received by \sh.  If \tt{Ref} is in the list of the receiver's in-progress computations, the computation is over, and send the result \tt{ComputationSoFar} back to the OW.  Otherwise, perform a step of the computation and forward the message to the next node's \sh.  & \{Pid, Ref, *\_key, ComputationSoFar\} \\

Joining behind. Received and sent by \sh.  When received, send all stored backup data to \tt{Pid}, then delete all backup data for processes numbered less than \tt{NodeID}.  Is sent by a new node with ID \tt{NodeID} to the pre-existing node that is sequentially after it. & \{Pid, joining\_behind, NodeID\} \\

Joining in front.  Received and sent by \sh.  When receiving such a message: if your ID is equal to \tt{DestID}, kill the data storage processes that the new node is now running (i.e. the ones numbered from \tt{NodeID} to the ID of the node after the new one. & \{joining\_front, NodeID, DestID\} \\

Node with \tt{NodeID} died.  Received by \sh, sent by a \gs{} listener started by that particular \sh.  When such a message is received, the \sh{} changes the node's ID to \tt{NodeID}, then uses all of the backup data it's holding to start up new data storage processes.  Then it deletes the backup data, and sends a \tt{backup\_request} message around the ring. & \{died, NodeID\} \\

Backup node data.  Received and sent by \sh.  When received, add all the data to existing backup data.  Sent to a node $A$'s successor when $A$'s predecessor died and $A$ is taking over for its predecessor.  & \{backup\_node, Data\} \\

Backup request.  Received and sent by \sh.  If it is received on the node with \tt{DestID}, send each of this node's \sp es an \tt{all\_data} message.  After compiling all of the results from those requests, send all of this node's stored data to this node's successor node in a \tt{backup\_node} message.  If this node is not \tt{DestID}, just forward the request message.  Initially sent by a node which stepped into the void left by a node that died.  & \{backup\_request, DestID\} \\

All data request message.  Received by \sp{} and sent by \sh.  When received by a \sp, respond with an \tt{all\_data\_send} message containing all this \sp's data.  & \{all\_data, Pid\} \\

All data send message.  Received by \sh{} and sent by \sp.  The \sh{} adds the received data to a \tt{backup\_request} message that's in progress; if it's the last response that was being waited for, send the \tt{backup\_request}. & \{all\_data, Data, Pid\}



%\textbf{Current state} & \textbf{Conditions} & \textbf{Actions} \\
%\hline
%\endhead
%\hline \multicolumn{3}{|r|}{{This table continues on the next page...}} \\ \hline
%\endfoot
%\endlastfoot
%
%Thinking & Receive a request for a fork & Send that fork \\*
%& Told to transition to \hungry & For each fork not currently held, send a fork request message to the corresponding neighbor.  Transition to \hungry. \\*
%& \emph{Receive a request for a new edge} & \emph{Add the new philosopher to my neighbor list and send a return message acknowledging that request.} \\*
%& \emph{Told to transition to \leaving} & \emph{For each fork not currently held, send a fork request message to the corresponding neighbor.  Transition to \leaving.} \\*
%& \emph{Receive a \leaving{} message} & \emph{Respond with an acknowledgement message.  Remove the corresponding philosopher from my list of neighbors, and remove all references to its fork.} \\*
%\hline
%Hungry & Receive a fork & Rejoice \\*
%& Receive a request for a fork, and that fork is \clean & Hold onto that request for later \\*
%& Receive a request for a fork, and that fork is \dirty & Send that fork, immediately followed by a message requesting that fork \\*
%& Hold all my forks & Transition to \eating{} and alert the controller to this \\*
%& \emph{Receive a request for a new edge} & \emph{Add the new philosopher to my neighbor list, send a message to the new neighbor acknowledging that request, then immediately send that philosopher a message requesting a fork.} \\*
%& \emph{Told to transition to \leaving} & \emph{Transition to \leaving.}\\*
%& \emph{Receive a \leaving{} message} & \emph{Respond with an acknowledgement message.  Remove the corresponding philosopher from my list of neighbors, and remove all references to its fork.} \\*
%\hline
%Eating & Receive a request for a fork & Hold onto that request for later \\*
%& Told to transition to \thinking &  Mark all forks dirty, and grant all pending requests for forks. \emph{Acknowledge all pending requests for edges and add any new philosophers to my neighbor list.}  Transition to \thinking. \\*
%& \emph{Receive a request for a new edge} & \emph{Hold onto that request for later} \\*
%& \emph{Told to transition to \leaving} & \emph{Acknowledge any pending new-edge requests and add any new philosophers to my neighbor list.  Ignore any pending fork requests.  Transition to \leaving.} \\*
%%& \emph{Receive a \leaving{} message} & \emph{This is, perhaps surprisingly, impossible.} \\*
%\hline
%\emph{Joining} & \emph{Come into existence in the joining state} & \emph{Send edge requests to all neighbors that I'm supposed to have.  Make sure all my forks are dirty.}\\*
%& \emph{Receive a request for a new edge} & \emph{Acknowledge that request and add the new philosopher to my neighbor list.} \\*
%& \emph{Receive a request for a fork} & \emph{Send that fork} \\*
%& \emph{Received acknowledgments to all requests for new edges} & \emph{Transition to \thinking{}} \\*
%& \emph{Receive a \leaving{} message} & \emph{Respond with an acknowledgement message.  Remove the corresponding philosopher from my list of neighbors, and remove all references to its fork.} \\*
%\hline 
%\emph{Leaving} & \emph{Receive a fork} & \emph{Rejoice} \\*
%& \emph{Receive a request for a fork, and that fork is \clean} & \emph{Ignore the request} \\*
%& \emph{Receive a request for a fork, and that fork is \dirty} & \emph{Send that fork, immediately followed by a message requesting that fork} \\*
%& \emph{Hold all my forks} & \emph{Send a \leaving{} message to each neighbor.  Mark all forks as \clean.} \\*
%& \emph{Receive a request for a new edge} & \emph{Add the new philosopher to my neighbor list, send a message to the new neighbor acknowledging that request, then immediately send that philosopher a message requesting a fork.} \\*
%& \emph{Receive a \leaving{} message} & \emph{Respond with an acknowledgement message.  Remove the corresponding philosopher from my list of neighbors, and remove all references to its fork.} \\*
%& \emph{Receive a \leaving{} acknowledgement} & \emph{Jubilate!} \\*
%& \emph{Have received a \leaving{} acknowledgement from every neighbor} & \emph{Transition to \gone{} and alert the controller to this.}\\*
%%\emph{Leaving} & \emph{Receive a fork} & \emph{Send its sender a \leaving{} message} \\
%%& \emph{Receive a request for a new edge} & \emph{Acknowledge that request and immediately send a \leaving{} message to that philosopher.  Don't bother adding it to my neighbor list since I won't be around long enough to care.} \\
%%& \emph{Receive a request for a fork} & \emph{Ignore the request} \\
%%& \emph{Have all of my forks} & \emph{Transition to \gone, and inform the controller of that} \\
%\hline
%\emph{Gone} & \emph{Anything happens} & \emph{Do nothing: I'm dead, Jim!}
\end{longtable}

\clearpage
\onehalfspacing

\section*{Correctness}



\end{document}
